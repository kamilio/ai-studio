version: 1
project: song-builder

overview: |
  Song Builder is a greenfield client-side web application for generating song lyrics and audio.
  Users iterate on lyrics via a chat interface backed by Claude (via Poe), then generate MP3 audio
  from those lyrics using ElevenLabs (also via Poe). A single POE_API_KEY gates all AI features.
  All data is persisted in localStorage — no backend is required. The app deploys to GitHub Pages
  via GitHub Actions, with build artifacts never committed to the main branch.

  The primary entity is a "lyrics entry" — a document with YAML frontmatter (title, style, commentary)
  and a lyrics body, plus an attached chat history. Songs are generated from a lyrics entry and stored
  alongside it. Deletions are always soft (a `deleted` flag), and nothing is ever hard-removed from storage.

  The stack is React + TypeScript + Vite, with shadcn/ui for components and Playwright for end-to-end
  and screenshot tests. Key architectural decisions: a single Poe API key covers both Claude and
  ElevenLabs; parallel song generation (N at a time, configurable); import/export of all localStorage
  data with an opt-in to include the API key. All LLM access is behind a typed LLMClient interface
  with a real (Poe) and a mock (fixture-based) implementation. Mock fixtures are pre-recorded real
  API responses produced by scripts/generate-fixtures.ts and committed to the repo. All tests and
  Playwright MCP QA always run against the mock client (VITE_USE_MOCK_LLM=true); no live API calls
  are made during testing.

goals:
  - Scaffold a production-ready React + TypeScript + Vite project with shadcn/ui and Playwright
  - Implement a typed localStorage data layer for lyrics entries, songs, and settings
  - Build the Lyrics Generator page with split-panel Claude chat and frontmatter display
  - Build the Song Generator page with parallel ElevenLabs audio generation and per-song actions
  - Build the Lyrics List page with search and soft-delete
  - Build the Pinned Songs page with play, unpin, and download actions
  - Build the Settings page with API key management and import/export
  - Implement the API key missing modal guard
  - Set up GitHub Actions for automated GitHub Pages deployment

nonGoals:
  - Any server-side or backend infrastructure
  - User authentication or accounts
  - Hard deletion of any data
  - Custom audio recording or editing
  - Lyrics versioning beyond the chat history

qualityGates:
  - npm run lint
  - npm run test
  - npm run build

requirements:
  - name: Project Scaffold
    description: >
      The project SHALL be initialized as a React + TypeScript Vite application with shadcn/ui,
      React Router for client-side routing, and Playwright for e2e and screenshot testing.
      NPM scripts SHALL include: dev, build, start, test, and screenshot:<page> for each page.
    scenarios:
      - name: Dev server starts
        when: Developer runs `npm run dev`
        then: A local dev server starts and the app is accessible in the browser
      - name: Production build succeeds
        when: Developer runs `npm run build`
        then: A production build is emitted to `dist/` with no errors
      - name: Tests run
        when: Developer runs `npm run test`
        then: Playwright test suite executes and reports results

  - name: LLM Client Abstraction
    description: >
      The app SHALL access all LLM functionality through a single LLMClient interface.
      A factory function SHALL return a MockLLMClient when VITE_USE_MOCK_LLM is true,
      and a PoeLLMClient otherwise. Mock fixtures SHALL be pre-recorded real API responses
      generated by scripts/generate-fixtures.ts and committed to the repo. The mock client
      SHALL return these recorded responses with a simulated delay. npm run test and
      Playwright MCP QA SHALL always run against the mock client; no live API calls SHALL
      be made during testing.
    scenarios:
      - name: Mock client returns recorded lyrics
        when: VITE_USE_MOCK_LLM=true and chat() is called
        then: The response is the contents of the committed lyrics-response.txt fixture (valid frontmatter)
      - name: Mock client returns recorded audio URL
        when: VITE_USE_MOCK_LLM=true and generateSong() is called
        then: The response is the audio URL from the committed song-response.json fixture
      - name: Fixture generation script produces valid files
        when: Developer runs `npm run generate:fixtures` with POE_API_KEY set
        then: lyrics-response.txt and song-response.json are written to src/lib/llm/fixtures/
      - name: Real client used in production
        when: npm run build is executed (VITE_USE_MOCK_LLM not set)
        then: The bundle uses PoeLLMClient
      - name: Tests always use mock
        when: npm run test or Playwright MCP QA is executed
        then: Playwright starts the dev server with VITE_USE_MOCK_LLM=true; no live API calls are made

  - name: Persistent Left Sidebar Navigation
    description: >
      The app SHALL render a persistent left sidebar visible on all pages. The sidebar SHALL contain
      icon + label links to: Lyrics Generator, Lyrics List, Song Generator, Pinned Songs, and Settings.
      The active route SHALL be visually highlighted.
    scenarios:
      - name: Sidebar visible on all pages
        when: User navigates to any page
        then: The left sidebar is rendered with all five navigation links
      - name: Active link highlighted
        when: User is on the Lyrics List page
        then: The Lyrics List link in the sidebar appears highlighted/selected

  - name: LocalStorage Data Layer
    description: >
      The app SHALL persist all data exclusively in localStorage using a typed schema.
      The schema SHALL include: settings (poeApiKey, numSongs), lyricsEntries (id, title, style,
      commentary, lyricsBody, chatHistory, deleted, createdAt, updatedAt), and songs
      (id, lyricsEntryId, audioUrl, songTitle, pinned, deleted, createdAt).
      All reads and writes SHALL go through a typed storage service.
    scenarios:
      - name: Settings persisted across reload
        when: User saves a POE_API_KEY in Settings and reloads the page
        then: The API key is still present in the Settings form
      - name: Lyrics entry persisted
        when: User creates a lyrics entry and reloads
        then: The entry appears in the Lyrics List
      - name: Soft delete preserved
        when: User soft-deletes a lyrics entry and reloads
        then: The entry does not appear in the Lyrics List

  - name: Lyrics Generator — Layout
    description: >
      The Lyrics Generator page SHALL render a two-panel layout: a left panel displaying the current
      lyrics in frontmatter format (YAML header + lyrics body), and a right panel with a chat interface.
      A "Generate Songs" button SHALL appear at the bottom of the page.
    scenarios:
      - name: Split panel layout renders
        when: User opens the Lyrics Generator
        then: Both the lyrics panel and the chat panel are visible
      - name: Frontmatter displayed
        when: A lyrics entry with title, style, and commentary is loaded
        then: The left panel shows YAML frontmatter followed by the lyrics body

  - name: Lyrics Generator — Claude Chat
    description: >
      The Lyrics Generator SHALL send user messages to Claude (model: claude-sonnet-4.5 via Poe)
      along with the full conversation history. Claude SHALL respond with updated lyrics in frontmatter
      format. The parsed frontmatter SHALL update the left panel. The conversation history SHALL be
      persisted per lyrics entry.
    scenarios:
      - name: User message triggers Claude call
        when: User submits a message in the chat panel
        then: The app calls the Poe API with the full conversation history and the new user message
      - name: Claude response updates lyrics panel
        when: Claude returns a response with frontmatter
        then: The left panel updates to display the new frontmatter and lyrics body
      - name: Conversation persisted
        when: User submits a message, reloads, and reopens the entry
        then: All previous messages are visible in the chat panel

  - name: Lyrics Generator — Generate Songs Button
    description: >
      The Lyrics Generator SHALL display a "Generate Songs" button that, when clicked, navigates
      to the Song Generator page in the context of the currently open lyrics entry.
    scenarios:
      - name: Button navigates to Song Generator
        when: User clicks "Generate Songs"
        then: The app navigates to the Song Generator page with the current lyrics entry as context

  - name: API Key Missing Modal
    description: >
      If the POE_API_KEY is absent when the user triggers any generation action (lyrics or songs),
      the app SHALL display a blocking modal instructing the user to go to Settings to add the key.
      No generation request SHALL be made while the key is missing.
    scenarios:
      - name: Modal shown on missing key — lyrics
        when: User submits a chat message and POE_API_KEY is not set
        then: A modal appears directing the user to Settings; no API call is made
      - name: Modal shown on missing key — songs
        when: User triggers song generation and POE_API_KEY is not set
        then: A modal appears directing the user to Settings; no API call is made

  - name: Song Generator — Parallel Generation
    description: >
      The Song Generator page SHALL generate N songs in parallel using the ElevenLabs-music model
      via Poe, where N defaults to 3 and is configurable in Settings. The page SHALL always operate
      on the currently open lyrics entry, pulling all metadata from the frontmatter automatically.
      Each generation request SHALL include a style prompt derived from the frontmatter and a
      music_length_ms of 300000.
    scenarios:
      - name: N songs generated in parallel
        when: User triggers song generation with numSongs=3
        then: Three concurrent requests are made to the Poe ElevenLabs-music endpoint
      - name: Style prompt from frontmatter
        when: Song generation is triggered
        then: The style prompt includes the title, style, and lyrics body from the current entry

  - name: Song Generator — Per-Song Actions
    description: >
      Each generated song SHALL support: Play (inline audio player), Pin (marks song as pinned),
      Delete (soft delete), and Download (fetches audio from URL and triggers browser save dialog).
    scenarios:
      - name: Play renders audio player
        when: User clicks Play on a song
        then: An inline HTML audio player appears for that song
      - name: Pin persists
        when: User pins a song and reloads
        then: The song appears in the Pinned Songs view
      - name: Soft delete hides song
        when: User deletes a song
        then: The song is hidden in the Song Generator list but remains in storage with deleted=true
      - name: Download triggers save dialog
        when: User clicks Download
        then: The browser's native save dialog opens for the audio file

  - name: Lyrics List — Table View
    description: >
      The Lyrics List page SHALL display a table of all non-deleted lyrics entries showing metadata
      (title, style) but not the full lyrics body. It SHALL provide text search over title and style.
      Clicking an entry SHALL open it in the Lyrics Generator. Each entry SHALL have a soft-delete action.
      A "New Lyrics" button in the header SHALL create a blank entry and open the Lyrics Generator.
    scenarios:
      - name: Entries listed
        when: User navigates to Lyrics List
        then: All non-deleted lyrics entries appear in the table
      - name: Search filters results
        when: User types in the search field
        then: Only entries whose title or style match the query are shown
      - name: Click entry opens generator
        when: User clicks a lyrics entry
        then: The Lyrics Generator opens with that entry loaded
      - name: New Lyrics creates entry
        when: User clicks "New Lyrics"
        then: A blank lyrics entry is created and the Lyrics Generator opens

  - name: Pinned Songs — View
    description: >
      The Pinned Songs page SHALL display all pinned, non-deleted songs with their associated
      metadata. Each song SHALL support: Play (inline audio player), Unpin, and Download.
    scenarios:
      - name: Pinned songs listed
        when: User navigates to Pinned Songs
        then: All pinned songs appear with their title and associated lyrics entry title
      - name: Unpin removes from view
        when: User unpins a song
        then: The song disappears from the Pinned Songs list
      - name: Download works from Pinned Songs
        when: User clicks Download on a pinned song
        then: The browser's native save dialog opens for the audio file

  - name: Settings — Configuration
    description: >
      The Settings page SHALL allow the user to configure: POE_API_KEY (text input), and number
      of songs to generate (numeric input, default 3). Changes SHALL be persisted to localStorage
      immediately on save.
    scenarios:
      - name: API key saved
        when: User enters a key and saves
        then: The key is persisted and used in subsequent API calls
      - name: Song count saved
        when: User changes numSongs to 5 and saves
        then: Song generation uses 5 parallel requests

  - name: Settings — Import/Export
    description: >
      The Settings page SHALL provide Import and Export actions for all localStorage data.
      Export SHALL produce a JSON file download. An opt-in checkbox ("Include API keys in export")
      SHALL control whether POE_API_KEY is included in the export. Import SHALL replace all
      localStorage data with the imported JSON.
    scenarios:
      - name: Export without API key
        when: User exports with "Include API keys" unchecked
        then: The downloaded JSON does not contain POE_API_KEY
      - name: Export with API key
        when: User exports with "Include API keys" checked
        then: The downloaded JSON contains POE_API_KEY
      - name: Import restores data
        when: User imports a valid JSON export file
        then: All lyrics entries and songs from the file appear in the app after reload

  - name: GitHub Actions Deployment
    description: >
      The repository SHALL include a GitHub Actions workflow that builds the app and deploys it
      to GitHub Pages on every push to main. Build artifacts SHALL NOT be committed to the main branch.
    scenarios:
      - name: Push to main triggers deploy
        when: A commit is pushed to main
        then: GitHub Actions runs the build and deploys to the gh-pages branch or Pages environment

stories:
  - id: US-001
    title: Initialize project scaffold
    status: open
    dependsOn: []
    description: >
      As a developer, I want a working React + TypeScript + Vite project with shadcn/ui, React Router,
      and Playwright configured, so that I have a foundation to build on.
    acceptanceCriteria:
      - "`npm run dev` starts a local dev server with no errors"
      - "`npm run build` produces a `dist/` folder with no errors"
      - "`npm run lint` passes with no errors"
      - "`npm run test` runs Playwright and exits (even with zero tests)"
      - "shadcn/ui is installed and a sample component renders"
      - "React Router is installed and a basic route structure exists"

  - id: US-002
    title: Define TypeScript data models, localStorage service, and import/export
    status: open
    dependsOn:
      - US-001
    description: >
      As a developer, I want typed TypeScript interfaces, a localStorage service, and an import/export
      function, so that all data access is consistent and test infrastructure can seed state through
      the same code path users take when importing data.
    acceptanceCriteria:
      - "TypeScript interfaces defined for: Settings, LyricsEntry, Song"
      - "Storage service exposes CRUD operations for each entity"
      - "All soft-delete operations set `deleted: true` rather than removing the record"
      - "A `storageService.import(json)` function accepts the same JSON format as the export and loads it into localStorage"
      - "A `storageService.export()` function serializes all localStorage data to JSON"
      - "Playwright tests cover round-trip read/write and import/export for each entity type"
      - "All quality gates pass: `npm run lint`, `npm run test`, `npm run build`"
      - "Playwright MCP QA: agent uses Playwright MCP to simulate user flows and confirm the page renders and behaves correctly"

  - id: US-003
    title: Set up integration test infrastructure
    status: open
    dependsOn:
      - US-001
      - US-002
    description: >
      As a developer, I want a shared Playwright test infrastructure backed by the app's own import
      function, so that every feature story can seed realistic state and write tests without boilerplate.
      Tests MUST seed state by calling `storageService.import(fixture)` — the same function the Settings
      import UI calls — ensuring test state flows through the same code path as real users.
    acceptanceCriteria:
      - "A `fixtures/` directory contains typed fixture data for LyricsEntry, Song, and Settings in the export JSON format"
      - "A `test/helpers/seed.ts` utility calls `storageService.import(fixture)` via `page.evaluate` to seed state before tests"
      - "A `test/helpers/screenshot.ts` utility seeds a fixture then captures a full-page screenshot"
      - "`npm run screenshot:<page>` script pattern is wired up (scripts may no-op until pages exist)"
      - "Playwright config targets the dev server with the correct base URL"
      - "A smoke test navigates to `/`, seeds empty state via the import function, and asserts the page loads"
      - "All quality gates pass: `npm run lint`, `npm run test`, `npm run build`"
      - "Playwright MCP QA: agent uses Playwright MCP to simulate user flows and confirm the page renders and behaves correctly"

  - id: US-004
    title: Implement LLM client abstraction with mock and real providers
    status: open
    dependsOn:
      - US-001
      - US-002
      - US-003
    description: >
      As a developer, I want a typed LLMClient interface with interchangeable real (Poe) and mock
      implementations, so that the app runs fully offline during development and all tests — including
      Playwright MCP QA — never make live API calls.

      Design:
        src/lib/llm/
          types.ts            — LLMClient interface: chat() and generateSong()
          poe-client.ts       — PoeLLMClient: wraps OpenAI SDK with Poe baseURL and POE_API_KEY
          mock-client.ts      — MockLLMClient: reads from recorded fixture files, adds simulated delay
          factory.ts          — createLLMClient(): returns mock when VITE_USE_MOCK_LLM=true, else Poe
          fixtures/
            lyrics-response.txt   — recorded Claude response (valid frontmatter + lyrics body)
            song-response.json    — recorded ElevenLabs response { audioUrl: "..." }

      Fixture generation (run once by developer with a real API key):
        scripts/generate-fixtures.ts
          — reads POE_API_KEY from env
          — calls PoeLLMClient.chat() with a seed prompt ("write a short pop song about coffee")
          — calls PoeLLMClient.generateSong() with a matching style prompt
          — writes the raw responses to src/lib/llm/fixtures/
          — committed to the repo; MockLLMClient reads these files at runtime

        npm run generate:fixtures  →  npx tsx scripts/generate-fixtures.ts

      Switch mechanism:
        - VITE_USE_MOCK_LLM env var (true/false)
        - npm run dev:mock  →  VITE_USE_MOCK_LLM=true vite
        - npm run test      →  Playwright webServer sets VITE_USE_MOCK_LLM=true (no live API calls ever)
        - Playwright MCP QA runs against the same mock server
        - Production build (npm run build) never sets VITE_USE_MOCK_LLM; PoeLLMClient is used
    acceptanceCriteria:
      - "LLMClient interface is defined with `chat(messages): Promise<string>` and `generateSong(prompt): Promise<string>`"
      - "PoeLLMClient implements LLMClient using the OpenAI SDK with Poe baseURL and dangerouslyAllowBrowser"
      - "MockLLMClient implements LLMClient, reads from fixture files, and adds a configurable simulated delay"
      - "createLLMClient() returns MockLLMClient when VITE_USE_MOCK_LLM=true, PoeLLMClient otherwise"
      - "`scripts/generate-fixtures.ts` exists and, when run with POE_API_KEY set, writes fixture files to `src/lib/llm/fixtures/`"
      - "`npm run generate:fixtures` script is defined in package.json"
      - "Fixture files (`lyrics-response.txt`, `song-response.json`) are committed to the repo"
      - "`npm run dev:mock` starts the dev server with the mock client active"
      - "Playwright webServer config sets VITE_USE_MOCK_LLM=true so all automated tests and Playwright MCP QA use the mock client"
      - "MockLLMClient fixture lyrics response is valid frontmatter (parseable title, style, commentary + body)"
      - "MockLLMClient fixture song response contains a usable audio URL"
      - "All quality gates pass: `npm run lint`, `npm run test`, `npm run build`"
      - "Playwright MCP QA: agent uses Playwright MCP to simulate user flows and confirm the page renders and behaves correctly"

  - id: US-005
    title: Implement persistent left sidebar navigation
    status: open
    dependsOn:
      - US-002
      - US-003
    description: >
      As a user, I want a persistent left sidebar with icon + label links to all five pages,
      so that I can navigate the app from anywhere.
    acceptanceCriteria:
      - "Sidebar is visible on all five pages"
      - "Sidebar contains links to: Lyrics Generator, Lyrics List, Song Generator, Pinned Songs, Settings"
      - "Active route link is visually distinguished"
      - "Playwright test: navigating each link lands on the correct page"
      - "Screenshot test: sidebar renders correctly with active state (seeded via storageService.import)"
      - "All quality gates pass: `npm run lint`, `npm run test`, `npm run build`"
      - "Playwright MCP QA: agent uses Playwright MCP to simulate user flows and confirm the page renders and behaves correctly"

  - id: US-006
    title: Implement Settings page
    status: open
    dependsOn:
      - US-002
      - US-003
      - US-005
    description: >
      As a user, I want to configure my API key and song count, and trigger import/export of all my
      data, so that I can manage the app's configuration and back up my work.
      The import/export logic lives in storageService (US-002); this story wires the UI to those functions.
    acceptanceCriteria:
      - "POE_API_KEY input saves to localStorage on submit"
      - "numSongs input (default 3) saves to localStorage on submit"
      - "Export button calls storageService.export() and downloads the resulting JSON"
      - "\"Include API keys in export\" checkbox controls whether POE_API_KEY appears in the export"
      - "Import button accepts a JSON file and calls storageService.import() to replace all data"
      - "Playwright test: save API key, reload, assert key is pre-filled"
      - "Playwright test: export → import round-trip restores all seeded data (seeded via storageService.import)"
      - "Playwright screenshot test with seeded fixture data"
      - "All quality gates pass: `npm run lint`, `npm run test`, `npm run build`"
      - "Playwright MCP QA: agent uses Playwright MCP to simulate user flows and confirm the page renders and behaves correctly"

  - id: US-007
    title: Implement API key missing modal
    status: open
    dependsOn:
      - US-003
      - US-006
    description: >
      As a user, I want a blocking modal to appear when I trigger generation without a POE_API_KEY,
      directing me to Settings, so that I understand what to do next.
      Note: in the mock client (VITE_USE_MOCK_LLM=true) this modal is still shown when POE_API_KEY
      is absent, keeping behaviour consistent between mock and real modes.
    acceptanceCriteria:
      - "Modal appears when POE_API_KEY is absent and user submits a chat message"
      - "Modal appears when POE_API_KEY is absent and user triggers song generation"
      - "No API request is made while the modal is shown"
      - "Modal contains a link or button that navigates to Settings"
      - "Playwright test: seed state without API key, trigger generation, assert modal is visible"
      - "Playwright test: seed state with API key set, trigger generation, assert modal is absent"
      - "All quality gates pass: `npm run lint`, `npm run test`, `npm run build`"
      - "Playwright MCP QA: agent uses Playwright MCP to simulate user flows and confirm the page renders and behaves correctly"

  - id: US-008
    title: Implement Lyrics List page
    status: open
    dependsOn:
      - US-003
      - US-005
    description: >
      As a user, I want to see all my lyrics entries in a searchable table, create new ones,
      and soft-delete existing ones.
    acceptanceCriteria:
      - "Table lists all non-deleted lyrics entries with title and style columns"
      - "Text search filters entries by title or style in real time"
      - "Clicking a row opens the Lyrics Generator with that entry"
      - "\"New Lyrics\" button creates a blank entry and navigates to Lyrics Generator"
      - "Soft-delete action marks entry as deleted and removes it from the table"
      - "Playwright test: seed entries via storageService.import, verify search, click, and delete"
      - "Playwright screenshot test with seeded fixture data"
      - "All quality gates pass: `npm run lint`, `npm run test`, `npm run build`"
      - "Playwright MCP QA: agent uses Playwright MCP to simulate user flows and confirm the page renders and behaves correctly"

  - id: US-009
    title: Implement Lyrics Generator layout and frontmatter display
    status: open
    dependsOn:
      - US-003
      - US-005
    description: >
      As a user, I want a split-panel view with my lyrics (in frontmatter format) on the left
      and a chat interface on the right, plus a "Generate Songs" button.
    acceptanceCriteria:
      - "Left panel displays YAML frontmatter (title, style, commentary) followed by lyrics body"
      - "Right panel contains a scrollable message history and a text input with send button"
      - "\"Generate Songs\" button is present at the bottom of the page"
      - "Clicking \"Generate Songs\" navigates to the Song Generator for the current entry"
      - "Playwright test: seed an entry via storageService.import, assert both panels render correctly"
      - "Playwright screenshot test with seeded fixture data"
      - "All quality gates pass: `npm run lint`, `npm run test`, `npm run build`"
      - "Playwright MCP QA: agent uses Playwright MCP to simulate user flows and confirm the page renders and behaves correctly"

  - id: US-010
    title: Implement Claude chat integration in Lyrics Generator
    status: open
    dependsOn:
      - US-003
      - US-004
      - US-007
      - US-009
    description: >
      As a user, I want to chat with Claude to iterate on my lyrics, with the response automatically
      updating the left panel and the conversation persisted.
      Uses createLLMClient() — in tests this is the MockLLMClient returning fixture lyrics.
    acceptanceCriteria:
      - "Submitting a message calls llmClient.chat() with the full conversation history"
      - "The response (frontmatter text) is parsed and updates the left panel"
      - "Conversation history is persisted to localStorage for the current entry"
      - "Reloading and reopening the entry shows the full chat history"
      - "A loading indicator is shown while awaiting the response"
      - "Playwright test: seed entry via storageService.import, submit message, assert MockLLMClient fixture lyrics appear in left panel and chat history persists through reload"
      - "All quality gates pass: `npm run lint`, `npm run test`, `npm run build`"
      - "Playwright MCP QA: agent uses Playwright MCP to simulate user flows and confirm the page renders and behaves correctly"

  - id: US-011
    title: Implement Song Generator page with parallel ElevenLabs generation
    status: open
    dependsOn:
      - US-003
      - US-004
      - US-007
      - US-009
    description: >
      As a user, I want to generate N songs in parallel from the current lyrics entry using
      ElevenLabs via Poe, and see them listed with playback controls.
      Uses createLLMClient() — in tests this is the MockLLMClient returning a fixture audio URL.
    acceptanceCriteria:
      - "Page always operates on the currently open lyrics entry"
      - "Triggering generation calls llmClient.generateSong() N times concurrently"
      - "Each call receives a style prompt derived from the frontmatter"
      - "N defaults to 3 and respects the value from Settings"
      - "Generated songs appear as list items with inline audio player"
      - "Songs are persisted to localStorage under the current lyrics entry"
      - "A loading state is shown per song during generation"
      - "Playwright test: seed lyrics entry via storageService.import, trigger generation, assert N songs rendered with MockLLMClient fixture audio URL and persisted to storage"
      - "Playwright screenshot test with seeded fixture data"
      - "All quality gates pass: `npm run lint`, `npm run test`, `npm run build`"
      - "Playwright MCP QA: agent uses Playwright MCP to simulate user flows and confirm the page renders and behaves correctly"

  - id: US-012
    title: Implement per-song actions (play, pin, delete, download)
    status: open
    dependsOn:
      - US-003
      - US-011
    description: >
      As a user, I want to play, pin, soft-delete, and download each generated song.
    acceptanceCriteria:
      - "Play renders an inline HTML audio player for the song's URL"
      - "Pin sets the song's `pinned` flag to true in localStorage"
      - "Delete sets the song's `deleted` flag to true; song is hidden from the list"
      - "Download fetches the audio URL and triggers the browser's native save dialog"
      - "Playwright tests: seed songs via storageService.import, verify each action updates localStorage correctly"
      - "All quality gates pass: `npm run lint`, `npm run test`, `npm run build`"
      - "Playwright MCP QA: agent uses Playwright MCP to simulate user flows and confirm the page renders and behaves correctly"

  - id: US-013
    title: Implement Pinned Songs page
    status: open
    dependsOn:
      - US-003
      - US-005
      - US-012
    description: >
      As a user, I want to see all my pinned songs in one place with play, unpin, and download actions.
    acceptanceCriteria:
      - "All pinned, non-deleted songs are listed"
      - "Each song shows its title and the associated lyrics entry title"
      - "Play renders an inline audio player"
      - "Unpin sets `pinned: false` and removes the song from the view"
      - "Download triggers the browser's native save dialog"
      - "Playwright test: seed pinned songs via storageService.import, assert they appear; unpin one, assert it disappears"
      - "Playwright screenshot test with seeded fixture data"
      - "All quality gates pass: `npm run lint`, `npm run test`, `npm run build`"
      - "Playwright MCP QA: agent uses Playwright MCP to simulate user flows and confirm the page renders and behaves correctly"

  - id: US-014
    title: Set up GitHub Actions deployment to GitHub Pages
    status: open
    dependsOn:
      - US-001
    description: >
      As a developer, I want a GitHub Actions workflow that builds and deploys the app to GitHub Pages
      on every push to main, without committing build artifacts to the main branch.
    acceptanceCriteria:
      - "`.github/workflows/deploy.yml` exists"
      - "Workflow runs `npm ci && npm run build` on push to main"
      - "Workflow deploys `dist/` to the gh-pages branch or GitHub Pages environment"
      - "Build artifacts are not committed to main"
      - "All quality gates pass: `npm run lint`, `npm run test`, `npm run build`"
      - "Playwright MCP QA: agent uses Playwright MCP to simulate user flows and confirm the page renders and behaves correctly"
